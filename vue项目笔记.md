# 笔记

## axios二次封装
> 前端要向服务器发请求，可以通过这些方式：XMLHttpRequest、fetch、jQuery、axios（项目中常用）

### 为什么需要进行二次封装axios？
> 主要目的是：设置请求拦截器和响应拦截器
- 请求拦截器：可以在发请求之前处理一些业务
- 响应拦截器：当服务器数据返回以后，可以处理一些事情
- 在项目当中经常会出现API文件夹【关于axios】
- 可以参考axios文档


## 接口统一管理
- 项目很小且接口一到两个：完全可以在组件的生命周期函数中发请求
- 项目很大且接口很多：就需要对接口统一管理


## nprogress进度条的使用
> 安装nprogress -- npm i nprogress
nprogress是一个对象，其中有两个方法是用来实现进度条的：
- start：进度条开始
- done：进度条结束
- 进度条的颜色是可以修改的，这是需要修改nprogress中的样式文件，即nprogress.css


> 若小仓库里开启了命名空间，则调用方法时，必须在前面写上归属哪个小仓库（home），不然路径有问题！


## 完成一级分类动态添加背景颜色
1. 第一种解决方案：采用样式完成（可以的）

   ```less
   .item:hover {
       background: skyblue;
   }
   ```

2. 第二种解决方案：通过JS完成


## 演示卡顿现象
正常：事件触发非常频繁，而且每一次的触发，回调函数都要去执行（如果时间很短，而回调函数内部有计算，那么很可能出现浏览器卡顿）
节流：在规定的间隔时间范围内不会重复触发回调，只有大于这个时间间隔才会触发回调，把频繁触发变为少量触发
防抖：前面的所有的触发都被取消，最后一次执行在规定的时间之后才会触发，也就是说如果连续快速的触发，只会执行一次


## 函数的防抖与节流
> 自己手写防抖与节流是需要学会【闭包+延迟器】

**如果不会，可以引入第三方的lodash，用其中的两个函数来实现：```debounce```与```throttle```。其中```debounce```是用来实现防抖的，而```throttle```是用来实现节流的。（注：lodash是脚手架自带的）**

- 节流：在规定的间隔时间范围内不会重复触发回调，只有大于这个时间间隔才会触发回调，把频繁触发变为少量触发

- 防抖：前面的所有的触发都被取消，最后一次执行在规定的时间之后才会触发，也就是说如果连续快速的触发，只会执行一次
- **理解：**
  - 可以将**防抖**理解为游戏里的回城技能
  - 可以将**节流**理解为游戏里技能的冷却时间


## mock数据
mock（模拟）数据：如果想要mock数据，需要用到一个插件mockjs
**使用的步骤：**
1. 在项目当中的src文件夹中创建mock文件夹
2. 准备好JSON数据（mock文件夹中创建相应的JSON文件）
3. 把mock数据需要的图片放置到public文件夹中（public文件夹在打包的时候，会把相应的资源原封不动打包到dist文件夹中）
4. 创建mockServer.js通过mockjs插件实现模拟数据
5. mockServer.js文件在入口文件中引入


## swiper插件
> swiper插件：经常制作轮播图（移动端|PC端都可以使用）

**使用步骤：**
1. 先通过```npm i swiper```安装好swiper（如果要指定版本的swiper，就只需要加上“@版本号”即可）
2. 引入相应的依赖包（swiper.css|swiper.js）
3. 页面中的结构务必要有
4. 初始化swiper实例（即new swiper），给轮播图添加动态效果


## 组件通信的方式有哪些？（面试频率极高）
- props：用于父子组件间的通信
- 自定义事件：可以实现子组件给父组件通信（$on、$emit、$off）
- 全局事件总线：$bus（全能）
- pubsub-js：vue当中几乎不用（全能）
- 插槽
- vuex


## 分页功能实现
为什么很多项目采用分页功能：因为当展示的数据过多时，如果不使用分页功能的话，一次性将所有数据展示出来会引起浏览器卡顿

**分页器展示，需要哪些数据（条件）？**
- 需要知道当前是第几页：pageNo字段代表当前页数
- 需要知道每一页需要展示多少条数据：pageSize字段进行代表
- 需要知道整个分页器一共有多少数据：total字段进行代表 --- [同时也能获取另外一条信息：一共有多少页]
- 需要知道分页器连续页码的个数：一般是5|7【奇数】 --- 因为奇数对错（好看）
- 总结：对于分页器而言，自定义前提需要知道四个前提条件
  1. pageNo：当前第几页
  2. pageSize：代表每一页展示多少条数据
  3. total：代表整个分页一共要展示多少条数据
  4. continues：代表分页连续页码个数

> 举个例子：每一页展示3条数据，一共91条数据，那么一共有31页


## @change、@input、@blur事件
- @change在输入框发生变化且失去焦点后触发；
- @input在输入框内容发生变化后触发（在界面加载数据以前）
- @blur失去焦点就触发

注意：
- @change先于@blur
- @input和change的默认参数为输入内容，而blur的默认参数为dom节点。


## Promise知识点
Promise.all([p1, p2, p3])
p1|p2|p3：每一个都是Promise对象。如果有一个Promise失败，那么就都失败；如果都成功，那么就都成功。


## 打包上线
项目打包后，代码都是经过压缩加密的，如果运行时报错，输出的错误信息无法准确得知是哪里的代码报错。
有了map文件就可以像未加密的代码一样，准确的输出是哪一行有错。
所以该文件如果项目不需要是可以去除掉的。
方法：
```js
  //在vue.config.js文件中进行配置
  productionSourceMap: false
```

## 补充知识点：
- assets文件夹：放置全部组件共用很高的静态资源
- 在JavaScript样式当中也可以使用@符号【src别名】，但切记要在前面加上~

> **vuex仓库存储数据，不是持久化的**
安装qrcode：npm i qrcode

项目登录测试的账号和密码：
13700000000       111111